package main

import (
	"database/sql"
	"fmt"
	"reflect"
	"time"

	_ "github.com/go-sql-driver/mysql"
)

var db *sql.DB

const (
	// Constant for table operations.
	TABLE_USERS     = "users"
	TABLE_PROJECTS  = "projects"
	TABLE_FILES     = "files"
	TABLE_AUTHORS   = "authors"
	TABLE_REVIEWERS = "reviewers"

	SELECT_ALL_ORDER_BY   = "SELECT %s FROM %s ORDER BY ?"
	SELECT_ROW            = "SELECT %s FROM %s WHERE %s = ?"
	SELECT_ROW_INNER_JOIN = "SELECT %s FROM %s INNER JOIN %s ON %s = %s WHERE %s = ?"
	SELECT_ROW_ORDER_BY   = "SELECT %s FROM %s ORDER BY ? WHERE %s = ?"
	INSERT_CRED           = "INSERT INTO %s (%s, %s, %s, %s) VALUES (?, ?, ?, ?)"
	INSERT_FULL           = "INSERT INTO %s (%s, %s, %s, %s, %s, %s, %s) VALUES (?, ?, ?, ?, ?, ?, ?)"
	UPDATE_ROWS           = "UPDATE %s SET %s = ? WHERE %s = ?"
	DELETE_ALL_ROWS       = "DELETE FROM %s"

	USERTYPE_NIL                = 0
	USERTYPE_PUBLISHER          = 1
	USERTYPE_REVIEWER           = 2
	USERTYPE_REVIEWER_PUBLISHER = 3
	USERTYPE_USER               = 4
)

var DB_PARAMS map[string]string = map[string]string{
	"interpolateParams": "true",
}

// Structure for user table.
type Credentials struct {
	// Password - given as plaintext by front end, and as hash by the database.
	Pw string `json:"password" db:"password" validate:"min=8,max=64,validpw"`
	// First Name.
	Fname string `json:"firstname" db:"firstName" validate:"nonzero,max=32"`
	// Last Name.
	Lname string `json:"lastname" db:"lastName" validate:"nonzero,max=32"`
	// Email Address.
	Email string `json:"email" db:"email" validate:"nonzero,max=100"`

	// User auto incremented ID.
	Id int `json:"userId" db:"id"`
	// User role.
	Usertype int `json:"usertype" db:"userType"`
	// User phone number.
	PhoneNumber string `json:"phonenumber" db:"phoneNumber" validate:"max=11"`
	// Organization name.
	Organization string `json:"organization" db:"organization" validate:"max=32"`
}

// Structure for code Projects
type Project struct {
	// unique id for the project as generated by the db
	id int `json:"id" db:"id"`
	// name of the project
	projectName string `json:"name" db:"projectName"`
	// the names of the project's reviewers
	reviewers []string `json:"reviewers"`
	// the names of the project's authors
	authors []string `json:"authors"`
	// file paths associated with the project
	filePaths []string `json:"files" db:"filePath"`

	// TEMP: add more fields (i.e. reviewer reviews)
}

// Structure for code files
type File struct {
	// unique id of the file as maintained in the db
	id int `json:"id" db:"id"`
	// id of the project this file is a part of
	projectID int `json:"project_id" db:"projectId"`
	// name of the project this file is a part of
	projectName string `json:"projectName"`
	// relative path to the file from the root of the project
	path string `json:"path" db:"filePath"`
	// base name of the file with extension
	name string `json:"name"`
	// content of the file encoded as a Base64 string
	content string `json:"content"`
	// user comments on the file
	comments []Comment `json:"comments"`
	// TEMP: add more fields (i.e. reviewer comments)
}

// Structure for user comments on code
type Comment struct {
	// author of the comment as an id
	AuthorID int `json:"author"`
	// time that the comment was recorded as a string TEMP: add functionality to decode to datetime here
	Time string `json:"time"`
	// replies TEMP: maybe don't allow nested replies?
	Replies []Comment `json:"replies"`
}

// Get the tag in a struct.
func getTag(v interface{}, structVar string, tag string) string {
	field, ok := reflect.TypeOf(v).Elem().FieldByName(structVar)
	if !ok {
		return ""
	} else {
		return field.Tag.Get(tag)
	}
}

// Get the database tag for a struct.
func getDbTag(v interface{}, structVar string) string {
	return getTag(v, structVar, "db")
}

// Get the database tag for a struct.
func getJsonTag(v interface{}, structVar string) string {
	return getTag(v, structVar, "json")
}

// Get database parameters string to place into DSN from a map.
func getDbParams(paramMap map[string]string) string {
	params := ""
	i := 0
	for key, val := range paramMap {
		if i > 0 {
			params += "&"
		}
		params += key + "=" + val
		i++
	}
	return params
}

// Initialise connection to the database.
func dbInit(user string, pw string, protocol string, h string, port int, dbname string) error {
	var err error

	// Set MySQL info in DSN format according to Go MySQL Drive -
	// user:password@protocol(host:port)/dbname?[param1=val...]
	mysqlInfo := fmt.Sprintf("%s:%s@%s(%s:%d)/%s?%s", user, pw, protocol, h, port, dbname,
		getDbParams(DB_PARAMS)) // Setting this to allow prepared statements.
	db, err = sql.Open("mysql", mysqlInfo)
	if err != nil {
		return err
	}

	// Set connection sanity options for database.
	db.SetConnMaxLifetime(time.Minute * 3)
	db.SetMaxOpenConns(10)
	db.SetMaxIdleConns(10)
	return nil
}

func dbCloseConnection() {
	db.Close()
}
