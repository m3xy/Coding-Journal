package main

import (
	"database/sql"
	"fmt"
	"log"
	"os"
	"reflect"
	"time"

	_ "github.com/go-sql-driver/mysql"
)

var db *sql.DB

const (
	TEAM_ID = "11"

	// Constant for table operations.
	VIEW_PERMISSIONS    = "globalPermissions"
	TABLE_SERVERS       = "servers"
	VIEW_LOGIN          = "globalLogins"
	TABLE_USERS         = "users"
	TABLE_SUBMISSIONS   = "submissions"
	TABLE_FILES         = "files"
	TABLE_AUTHORS       = "authors"
	TABLE_REVIEWERS     = "reviewers"
	TABLE_CATEGORIES    = "categories"
	TABLE_IDMAPPINGS    = "idMappings"
	VIEW_USER_INFO      = "globalUserInfo"
	VIEW_SUBMISSIONLIST = "submissionList"

	// TEMP: reconcile these
	INNER_JOIN    = "%s INNER JOIN %s"
	INSERT_DOUBLE = "INSERT INTO %s (%s, %s) VALUES (?, ?)"

	SELECT_ROW               = "SELECT %s FROM %s WHERE %s = ?"
	SELECT_EXISTS            = "SELECT EXISTS (SELECT %s FROM %s WHERE %s = ?)"
	SELECT_ROW_TWO_CONDITION = "SELECT %s FROM %s WHERE %s = ? AND %s = ?"
	SELECT_ALL_ORDER_BY      = "SELECT %s FROM %s ORDER BY ?"
	SELECT_ROW_INNER_JOIN    = "SELECT %s FROM %s INNER JOIN %s ON %s = %s WHERE %s = ?"
	SELECT_ROW_ORDER_BY      = "SELECT %s FROM %s ORDER BY ? WHERE %s = ?"
	INSERT_CRED              = "INSERT INTO %s (%s, %s, %s, %s) VALUES (?, ?, ?, ?)"
	INSERT_SUBMISSION		 = "INSERT INTO %s (%s, %s) VALUES (?, ?) RETURNING id"
	INSERT_FILE              = "INSERT INTO %s (%s, %s) VALUES (?, ?) RETURNING id"
	INSERT_AUTHOR            = "INSERT INTO %s VALUES (?, ?)"
	INSERT_REVIEWER          = "INSERT INTO %s VALUES (?, ?)"
	INSERT_CATEGORIES		 = "INSERT INTO %s VALUES (?, ?)"
	INSERT_FULL              = "INSERT INTO %s (%s, %s, %s, %s, %s, %s, %s) VALUES (?, ?, ?, ?, ?, ?, ?)"
	UPDATE_ROWS              = "UPDATE %s SET %s = ? WHERE %s = ?"
	DELETE_ALL_ROWS          = "DELETE FROM %s"

	USERTYPE_NIL                = 0
	USERTYPE_PUBLISHER          = 1
	USERTYPE_REVIEWER           = 2
	USERTYPE_REVIEWER_PUBLISHER = 3
	USERTYPE_USER               = 4
)

var DB_PARAMS map[string]string = map[string]string{
	"interpolateParams": "true",
}

// Structure for user table.
type Credentials struct {
	// User auto incremented ID.
	Id string `json:"userId" db:"id"`
	// Email Address.
	Email string `json:"email" db:"email" validate:"nonzero,max=100"`
	// Password - given as plaintext by front end, and as hash by the database.
	Pw string `json:"password,omitempty" db:"password" validate:"min=8,max=64,validpw"`
	// First Name.
	Fname string `json:"firstname" db:"firstName" validate:"nonzero,max=32"`
	// Last Name.
	Lname string `json:"lastname" db:"lastName" validate:"nonzero,max=32"`
	// User role.
	Usertype int `json:"usertype" db:"userType"`
	// User phone number.
	PhoneNumber string `json:"phonenumber" db:"phoneNumber" validate:"max=11"`
	// Organization name.
	Organization string `json:"organization" db:"organization" validate:"max=32"`
}

// Structure for ID mappings.
type IdMappings struct {
	GlobalId string `json:"globalId" db:"globalId"`
	Id       string `json:"userId" db:"localId"`
}

// Structure for code Submissions
type Submission struct {
	// unique id for the submisions as generated by the db
	Id int `json:"id" db:"id"`
	// name of the submission
	Name string `json:"name" db:"submissionName"`
	// date the code submission was created
	CreationDate string `json:"creationDate" db:"creationDate"`
	// license which the code is published under
	License string `json:"license" db:"license"`
	// the ids of the submission's reviewers
	Reviewers []string `json:"reviewers"`
	// the ids of the submission's authors
	Authors []string `json:"authors"`
	// relative paths of the files from the root of the submission 
	FilePaths []string `json:"files" db:"filePath"`
	// tags for organizing/grouping code submissions
	Categories []string `json:"categories" db:"tag"`
	// metadata about the submission
	MetaData *SubmissionData `json:"metadata"`
}

// Supergroup compliant code submissions
type SupergroupSubmission struct {
	// name of the submission
	Name string `json:"name"`
	// metadata about the submission
	MetaData *SupergroupSubmissionData `json:"metadata"`
	// file objects which are members of the submission
	Files []*SupergroupFile `json:"files"`
}

// structure for meta-data of the submission. matches the structure of the submission's JSON data file
type SubmissionData struct {
	// abstract for the submission, to be displayed upon opening of any given submission
	Abstract string `json:"abstract"`
	// reviewer comments on the overall submission
	Reviews []*Comment `json:"reviews"`
}

// supergroup compliant structure for meta-data of the submission
type SupergroupSubmissionData struct {
	// date the code submission was created
	CreationDate string `json:"creationDate"`
	// names of the authors listed on the submission
	AuthorNames []string `json:"authorNames"`
	// tags for organizing/grouping code submissions
	Categories []string `json:"categories"`
	// abstract for the submission, to be displayed upon opening of any given submission
	Abstract string `json:"abstract"`
	// license which the code is published under
	License string `json:"license"`
}

// Structure for code files
type File struct {
	// unique id of the file as maintained in the db
	Id int `json:"id" db:"id"`
	// id of the submission this file is a part of
	SubmissionId int `json:"submissionId" db:"submissionId"`
	// name of the submission this file is a part of
	SubmissionName string `json:"submissionName"`
	// relative path to the file from the root of the submission's file structure
	Path string `json:"filePath" db:"filePath"`
	// base name of the file with extension
	Name string `json:"filename"`
	// content of the file encoded as a Base64 string
	Base64Value string `json:"base64Value"`
	// structure to hold the data from the file's metadata file
	MetaData *FileData `json:"metadata"`
}

// Supergroup compliant file structure
type SupergroupFile struct {
	// name of the file as a string
	Name string `json:"filename"`
	// file content as a base64 encoded string
	Base64Value string `json: "base64Value"`
}

// structure to hold json data from data files
// no DB tags here as this data is stored in a file, not in the db
type FileData struct {
	// stores comments for the given code file
	Comments []*Comment `json:"comments"`
}

// Structure for user comments on code
type Comment struct {
	// author of the comment as an id
	AuthorId string `json:"author"`
	// time that the comment was recorded as a string
	Time string `json:"time"`
	// content of the comment as a string
	Base64Value string `json:"base64Value"`
	// replies TEMP: maybe don't allow nested replies?
	Replies []*Comment `json:"replies"`
}

// Structure for authors and reviewers
type AuthorsReviewers struct {
	SubmissionId int    `json:"submissionId" db:"submissionId"`
	Id           string `json:"id" db:"userId"`
}

// structure for categories
type Categories struct {
	SubmissionId int `db:"submissionId"`
	Tag string `db:"tag"`
}

// Structure for servers.
type Servers struct {
	GroupNb int    `json:"groupNumber" db:"groupNumber"`
	Token   string `json:"token" db:"token"`
	Url     string `json:"url" db:"url"`
}

// Get the tag in a struct.
func getTag(v interface{}, structVar string, tag string) string {
	field, ok := reflect.TypeOf(v).Elem().FieldByName(structVar)
	if !ok {
		return ""
	} else {
		return field.Tag.Get(tag)
	}
}

// Check if a value is unique in a given table.
func checkUnique(table string, varName string, val string) bool {
	// Query prepared and formatted statement.
	stmt := fmt.Sprintf(SELECT_ROW, varName, table, varName)
	query := db.QueryRow(stmt, val)

	// Scan query and check for existing rows.
	var res interface{}
	err := query.Scan(&res)
	if err != sql.ErrNoRows {
		// Table isn't empty or error occured, return false.
		if err != nil {
			log.Printf("Scan error on checkUnique: %v\n", err)
		}
		return false
	} else {
		return true
	}
}

// Get the database tag for a struct.
func getDbTag(v interface{}, structVar string) string {
	return getTag(v, structVar, "db")
}

// Get the database tag for a struct.
func getJsonTag(v interface{}, structVar string) string {
	return getTag(v, structVar, "json")
}

// Get database parameters string to place into DSN from a map.
func getDbParams(paramMap map[string]string) string {
	params := ""
	i := 0
	for key, val := range paramMap {
		if i > 0 {
			params += "&"
		}
		params += key + "=" + val
		i++
	}
	return params
}

// Initialise connection to the database.
func dbInit(dbname string) error {
	var err error

	// Set MySQL info in DSN format according to Go MySQL Drive -
	// user:password@protocol(host:port)/dbname?[param1=val...]
	mysqlInfo := fmt.Sprintf("%s/%s?%s", os.Getenv("DATABASE_URL"), dbname,
		getDbParams(DB_PARAMS)) // Setting this to allow prepared statements.
	db, err = sql.Open("mysql", mysqlInfo)
	if err != nil {
		return err
	}

	// Set connection sanity options for database.
	db.SetConnMaxLifetime(time.Minute * 3)
	db.SetMaxOpenConns(10)
	db.SetMaxIdleConns(10)
	return nil
}

// Close a database connection.
// WARNING: this function clears all data from the database, setting it
// back to the state it'd be in
func dbClear() error {
	// db tables to clear ORDER MATTERS HERE DUE TO KEY CONSTRAINTS
	tablesToClear := []string{
		TABLE_AUTHORS,
		TABLE_REVIEWERS,
		TABLE_IDMAPPINGS,
		TABLE_CATEGORIES,
		TABLE_FILES,
		TABLE_SUBMISSIONS,
		TABLE_USERS,
	}
	// formats and executes a delete command for each table
	for _, table := range tablesToClear {
		stmt := fmt.Sprintf(DELETE_ALL_ROWS, table)
		_, err := db.Exec(stmt)
		if err != nil {
			return err
		}
	}
	return nil
}

// Close database connection.
func dbCloseConnection() {
	db.Close()
}

// Get all columns from an interface.
func getCols(v interface{}) []interface{} {
	s := reflect.ValueOf(v).Elem()
	numCols := s.NumField()
	cols := make([]interface{}, numCols)
	for i := 0; i < numCols; i++ {
		cols[i] = s.Field(i).Addr().Interface()
	}
	return cols
}
